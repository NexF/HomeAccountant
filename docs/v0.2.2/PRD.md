# 家庭记账 - 产品需求文档 (PRD)

> **版本：v0.2.2**
> **创建日期：2026-02-14**
> **基于版本：v0.2.1**
> **状态：规划中**
> **本版本变更：末级科目记账约束 + 科目体系重构（货币资金 / 现金等价物）**

---

## 1. 版本概述

### 1.1 版本目标

v0.2.2 解决一个核心会计规范问题：**当前系统允许往任意层级的科目记账（包括父科目），这不符合会计准则**。本版本引入「末级科目（叶子节点）才能记账」的约束，同时完成上一版本已规划的科目体系重构。

| 能力 | 核心价值 |
|------|---------|
| 末级科目记账约束（后端） | 创建/编辑分录时校验所选科目必须为叶子节点，拒绝选择含子科目的父级科目 |
| 末级科目记账约束（前端） | AccountPicker 中父节点仅用于展开/折叠，不可选中；仅叶子节点可被选择 |
| 科目删除/停用保护 | 有分录引用的科目不能删除或停用，有子科目的科目不能删除或停用 |
| 科目体系重构 | 原「现金 + 银行存款 + 第三方支付」合并为「货币资金」大类；新增「现金等价物」大类 |
| 科目树 API 增强 | 返回 `is_leaf` 标记，方便前端和 MCP 客户端判断 |

### 1.2 问题背景

当前系统中，用户记账时可以选择科目树中的任意节点。例如：

```
1001 货币资金          ← 父科目，不应直接记账
├── 1001-01 现金       ← 叶子，可以记账
└── 1001-02 存款       ← 父科目（含子科目），不应直接记账
    ├── 1001-0201 工商银行  ← 叶子，可以记账
    └── 1001-0202 招商银行  ← 叶子，可以记账
```

如果用户将一笔 ¥100 记到「1001 货币资金」，同时另一笔 ¥200 记到「1001-0201 工商银行」，那么「1001 货币资金」的余额应该是 ¥100 还是 ¥300？这产生了**语义歧义**：

- 如果余额 = 自身发生额（¥100）→ 与子科目汇总不一致
- 如果余额 = 自身 + 子节点汇总（¥300）→ 父科目自身的 ¥100 无法区分归属

**解决方案**：遵循主流会计软件（用友、金蝶）的做法 —— **只有末级科目（叶子节点）才能记账**。父科目仅作为分类汇总用途。

### 1.3 设计决策

| 决策项 | 选择 | 理由 |
|--------|------|------|
| 叶子节点判定方式 | 运行时查询 `children` 是否为空 | 不需要新增字段，与现有 `parent_id` 自引用结构兼容 |
| API 返回 `is_leaf` | Schema 中增加计算字段 | 前端和 MCP 客户端无需自行遍历 children 判断 |
| 父节点已有分录的处理 | 自动迁移：创建「待分类」子科目并迁移分录行 | 保证数据干净，所有分录都指向叶子节点，报表逻辑无歧义 |
| 前端 AccountPicker | 父节点仅展开/折叠，点击不触发选择 | 从交互层面阻止误选 |
| 后端校验 | 在 `_get_account` 中增加叶子节点检查 | 作为最终防线，即使前端绕过也无法提交 |

### 1.4 不包含的内容（留待后续版本）

- 科目合并/拆分功能
- 科目停用时自动迁移子科目余额
- 用户自定义科目层级（当前最多 3 级）
- 分录类型转换功能完善（v0.2.1 已置灰，暂不处理）

---

## 2. 功能需求：末级科目记账约束

### 2.1 核心规则

**规则 R1：只有末级科目（没有子科目的科目）才允许作为分录行的记账科目。**

具体来说：

- 创建分录时，`category_account_id` 和 `payment_account_id` 必须是叶子节点
- 编辑分录时，如果变更了科目，新科目必须是叶子节点
- 批量记账 API（`POST /plugins/{id}/entries/batch`）同样受此约束
- MCP Tool `create_entries` 同样受此约束（通过底层 API 自动生效）

**规则 R2：当一个原本的叶子科目新增了子科目后，该科目自动变为非末级科目，不再允许直接记账。**

- 例如：如果用户在「5001 餐饮饮食」下新增了「5001-01 外卖」和「5001-02 堂食」，则「5001 餐饮饮食」自动不可记账

**规则 R3：当科目从叶子变为非叶子时，系统自动迁移该科目上的历史分录。**

- 自动在该科目下创建「{父科目编码}-99 待分类{父科目名称}」子科目（如 `5001-99 待分类餐饮饮食`）
- 将所有引用该父科目的分录行（`entry_lines.account_id`）批量更新为指向新创建的待分类子科目
- 迁移完成后，该父科目上不再有直接关联的分录行，数据保持干净
- 用户后续可以在待分类子科目中逐条将分录改分到正确的子科目（如 `5001-01 外卖`）

### 2.2 后端校验

#### 2.2.1 `_get_account` 增强

在 `entry_service.py` 的 `_get_account()` 函数中增加叶子节点检查：

```
调用 _get_account(db, account_id, book_id)
  1. 查询科目存在、归属、激活 ← 现有逻辑
  2. 查询该科目是否有子科目（SELECT COUNT(*) FROM accounts WHERE parent_id = account_id AND is_active = True）
  3. 如果 count > 0 → 抛出 400 错误：「科目 {name}（{code}）为非末级科目，请选择其下的末级科目记账」
```

#### 2.2.2 新增辅助函数

```
async def _check_is_leaf(db, account_id) -> bool:
    """检查科目是否为叶子节点（无活跃子科目）"""
    count = SELECT COUNT(*) FROM accounts WHERE parent_id = {account_id} AND is_active = True
    return count == 0
```

#### 2.2.3 影响的函数

| 函数 | 影响 |
|------|------|
| `create_expense` | `category_account_id` + `payment_account_id` 均需校验 |
| `create_income` | 同上 |
| `create_asset_purchase` | 同上 |
| `create_borrow` | 同上 |
| `create_repayment` | 同上 |
| `create_transfer` | `from_account_id` + `to_account_id` 均需校验 |
| `create_manual_entry` | 所有 `lines[].account_id` 均需校验 |
| `update_entry` → `_rebuild_lines` | 变更科目时校验 |
| `convert_entry_type` | 新指定的科目需校验 |

### 2.3 前端 AccountPicker 改造

#### 2.3.1 交互变更

| 节点类型 | 当前行为 | 新行为 |
|---------|---------|--------|
| 父节点（有 children） | 点击 = 折叠/展开 + **选中** | 点击 = 仅折叠/展开，**不可选中** |
| 叶子节点（无 children） | 点击 = 选中 | 不变 |

#### 2.3.2 视觉区分

| 属性 | 父节点 | 叶子节点 |
|------|--------|---------|
| 文字颜色 | `textSecondary`（灰色） | `text`（正常颜色） |
| 点击反馈 | 无选中高亮 | 选中高亮 + 勾选图标 |
| 折叠箭头 | 显示 `chevron-down` / `chevron-right` | 不显示（空占位） |
| 光标 | `default`（不暗示可点选） | `pointer` |

#### 2.3.3 禁选提示

当用户点击父节点时，仅执行展开/折叠操作。不需要 Toast 提示（因为视觉上已经明确区分了可选和不可选）。

### 2.4 科目树 API 增强

#### 2.4.1 `AccountTreeNode` Schema 新增字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `is_leaf` | `bool` | 是否为末级科目（`children` 为空则 `true`） |

该字段由后端在构建树时自动计算，不存储在数据库中。

#### 2.4.2 响应示例

```json
{
  "asset": [
    {
      "id": "uuid-1001",
      "code": "1001",
      "name": "货币资金",
      "type": "asset",
      "is_leaf": false,
      "children": [
        {
          "id": "uuid-1001-01",
          "code": "1001-01",
          "name": "现金",
          "type": "asset",
          "is_leaf": true,
          "children": []
        },
        {
          "id": "uuid-1001-02",
          "code": "1001-02",
          "name": "存款",
          "type": "asset",
          "is_leaf": false,
          "children": [
            {
              "id": "uuid-1001-0201",
              "code": "1001-0201",
              "name": "工商银行",
              "type": "asset",
              "is_leaf": true,
              "children": []
            }
          ]
        }
      ]
    }
  ]
}
```

### 2.5 科目删除/停用保护

**规则 R4：有分录引用或有子科目的科目不能删除/停用。**

#### 2.5.1 保护条件

删除或停用科目时，需检查两个条件：

| 检查项 | 条件 | 拒绝原因 |
|--------|------|---------|
| 有关联分录行 | `entry_lines` 表中存在 `account_id` 指向该科目的记录 | 删除会导致分录行丢失科目引用，数据不完整 |
| 有活跃子科目 | `accounts` 表中存在 `parent_id` 指向该科目且 `is_active=True` 的记录 | 删除父科目会导致子科目变为孤儿 |

任一条件满足即拒绝操作。

#### 2.5.2 用户操作指引

当用户尝试删除/停用被保护的科目时，错误信息应包含操作指引：

- **有分录引用**：`科目「XX」（YY）下有 N 条分录引用，请先将这些分录迁移到其他科目后再删除`
- **有子科目**：`科目「XX」（YY）下有 N 个子科目，请先删除或迁移子科目后再删除`

#### 2.5.3 正确的删除流程

```
用户想删除「5001-99 待分类餐饮饮食」（上面有 3 条分录）
  ↓
Step 1: 将 3 条分录逐条/批量改科目到「5001-01 外卖」或「5001-02 堂食」
  ↓
Step 2: 此时「5001-99」上已无分录引用，可以成功删除/停用
```

### 2.6 错误信息

| 场景 | HTTP 状态码 | 错误信息 |
|------|------------|---------|
| 选择了父科目记账 | 400 | `科目「货币资金」（1001）为非末级科目，含 2 个子科目，请选择其下的末级科目记账` |
| 编辑时将科目改为父科目 | 400 | 同上 |
| 批量记账中某条选了父科目 | 400 | `第 {index} 条分录的科目「{name}」为非末级科目` |
| 删除有分录引用的科目 | 400 | `科目「{name}」（{code}）下有 {count} 条分录引用，请先将这些分录迁移到其他科目后再删除` |
| 删除有子科目的科目 | 400 | `科目「{name}」（{code}）下有 {count} 个子科目，请先删除或迁移子科目后再删除` |

---

## 3. 功能需求：科目体系重构

### 3.1 变更内容

| 变更 | 旧结构 | 新结构 |
|------|--------|--------|
| 现金 | `1001 现金`（一级叶子） | `1001 货币资金 > 1001-01 现金`（二级叶子） |
| 银行存款 | `1002 银行存款 > 1002-01/02`（二级） | `1001 货币资金 > 1001-02 存款 > 1001-0201/02`（三级） |
| 第三方支付 | `1003 第三方支付 > 1003-01/02`（二级） | 合并到 `1001-02 存款` 下：`1001-0203/04`（三级） |
| 现金等价物 | 无 | `1002 现金等价物 > 1002-01 货币基金 / 1002-02 短期国债`（新增） |

> 此变更已在 `server/app/utils/seed.py` 中完成。仅影响**新创建的账本**。

### 3.2 已有账本的迁移

已有账本的科目结构不会自动变更。如需迁移，提供以下方案：

#### 方案 A：手动迁移（推荐）

用户通过「科目管理」页面手动调整：
1. 在「1001 现金」下新增子科目
2. 将「1001 现金」改名为「货币资金」
3. 手动调整已有分录的科目

#### 方案 B：迁移脚本（可选）

提供一次性迁移脚本 `server/scripts/migrate_accounts_v022.py`，自动完成：
1. 重建科目层级
2. 将指向旧科目的分录行迁移到对应的新叶子科目

> 迁移脚本为可选交付物，视实际需求决定是否开发。

### 3.3 父节点已有分录的处理（自动迁移）

由于引入了末级科目约束，可能存在历史分录引用了当前的父科目（例如旧账本中直接记到「1002 银行存款」而非其子科目）。

**处理策略：自动迁移（R3 规则）**

当一个科目从叶子变为非叶子（即用户为其新增了子科目）时，系统自动执行以下操作：

#### 3.3.1 迁移触发时机

在「创建子科目」API (`POST /books/{book_id}/accounts`) 中，当检测到新科目的 `parent_id` 指向一个原本的叶子科目时触发迁移。

#### 3.3.2 迁移流程

```
用户给「5001 餐饮饮食」新增子科目「5001-01 外卖」
  ↓
Step 1: 检查「5001」是否有关联的 entry_lines
  ↓ (如果有)
Step 2: 自动创建「5001-99 待分类餐饮饮食」子科目
  - code: "{parent_code}-99"
  - name: "待分类{parent_name}"
  - type/balance_direction: 继承父科目
  - is_system: True
  - icon: "question-circle"
  ↓
Step 3: UPDATE entry_lines SET account_id = '5001-99的ID'
         WHERE account_id = '5001的ID'
  ↓
Step 4: 创建用户请求的子科目「5001-01 外卖」
  ↓
返回成功，附带迁移信息：
  "已将 N 条分录从「餐饮饮食」迁移至「待分类餐饮饮食」"
```

#### 3.3.3 迁移结果示例

**迁移前**：
```
5001 餐饮饮食 ← 有 15 条分录直接记在此科目
```

**迁移后**：
```
5001 餐饮饮食 ← 0 条直接分录（仅作分类汇总）
├── 5001-01 外卖     ← 新建的子科目
└── 5001-99 待分类餐饮饮食  ← 自动创建，承接原 15 条分录
```

#### 3.3.4 边界情况

| 场景 | 处理方式 |
|------|---------|
| 父科目上没有分录 | 不创建待分类子科目，直接新建用户请求的子科目 |
| `{parent_code}-99` 编码已存在 | 直接复用已存在的待分类科目，分录迁移到该科目 |
| 待分类科目清空后 | 用户可手动停用或保留，系统不自动清理 |
| 同时新增多个子科目 | 仅首次触发迁移，后续新增不再重复迁移 |

#### 3.3.5 API 响应增强

创建子科目的 API 响应新增 `migration` 字段：

```json
{
  "id": "uuid-new-account",
  "code": "5001-01",
  "name": "外卖",
  "migration": {
    "triggered": true,
    "fallback_account": {
      "id": "uuid-5001-99",
      "code": "5001-99",
      "name": "待分类餐饮饮食"
    },
    "migrated_lines_count": 15,
    "message": "已将 15 条分录从「餐饮饮食」迁移至「待分类餐饮饮食」"
  }
}
```

当无需迁移时：`"migration": { "triggered": false }`

---

## 4. 数据模型变更

### 4.1 Account 模型 — 无新增字段

`is_leaf` 不存储在数据库中，由运行时计算（`children` 列表是否为空）。

### 4.2 AccountTreeNode Schema — 新增计算字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `is_leaf` | `bool` | 树构建后根据 `children` 是否为空自动填充 |

### 4.3 seed.py — 已完成

科目重构的 seed 数据变更已在上一步完成：
- `1001` → 货币资金（父），下设现金(1001-01)、存款(1001-02)
- `1001-02` 存款下设工商银行(1001-0201)、招商银行(1001-0202)、支付宝(1001-0203)、微信钱包(1001-0204)
- `1002` → 现金等价物（父），下设货币基金(1002-01)、短期国债(1002-02)

---

## 5. 版本规划更新

### v0.0.1 (MVP) — 已完成 ✅
### v0.0.2 — 已完成 ✅
### v0.0.3 — 已完成 ✅
### v0.1.1 — 已完成 ✅
### v0.2.0 — 已完成 ✅
### v0.2.1 — 已完成 ✅

### v0.2.2 — 本版本

- [ ] 末级科目记账约束 — 后端
  - [ ] `_get_account` 增加叶子节点校验
  - [ ] `_check_is_leaf` 辅助函数
  - [ ] 所有创建/编辑/转换函数适配
  - [ ] 批量记账 API 适配
  - [ ] 错误信息友好提示
- [ ] 历史分录自动迁移
  - [ ] 创建子科目时检测父科目是否有关联分录行
  - [ ] 自动创建「待分类」子科目（`{code}-99`）
  - [ ] 批量迁移 `entry_lines.account_id`
  - [ ] API 响应返回迁移信息
  - [ ] 前端提示用户迁移结果
- [ ] 科目删除/停用保护
  - [ ] 删除/停用前检查是否有分录引用
  - [ ] 删除/停用前检查是否有活跃子科目
  - [ ] 拒绝操作并返回友好错误信息及操作指引
- [ ] 末级科目记账约束 — 前端
  - [ ] AccountPicker 父节点仅展开/折叠，不可选中
  - [ ] 父节点与叶子节点视觉区分
- [ ] 科目树 API 增强
  - [ ] `AccountTreeNode` 新增 `is_leaf` 字段
  - [ ] 前端 `AccountTreeNode` TypeScript 类型同步
- [ ] 测试
  - [ ] 后端单元测试：选择父科目记账 → 400 错误
  - [ ] 后端单元测试：选择叶子科目记账 → 正常
  - [ ] 后端单元测试：科目新增子科目后不可再记账
  - [ ] 后端单元测试：编辑分录变更为父科目 → 400 错误
  - [ ] 后端单元测试：新增子科目触发自动迁移
  - [ ] 后端单元测试：父科目无分录时不触发迁移
  - [ ] 后端单元测试：待分类科目编码冲突时复用
  - [ ] 后端单元测试：删除有分录引用的科目 → 400 错误
  - [ ] 后端单元测试：删除有子科目的科目 → 400 错误
  - [ ] 后端单元测试：删除无引用无子科目的科目 → 成功
  - [ ] 前端 AccountPicker 行为验证

### （远期）

- [ ] 分录类型转换功能完善
- [ ] 科目合并/拆分
- [ ] 家庭账本 & 多人协作
- [ ] CSV 账单导入 & 流水匹配对账
- [ ] 数据导出（CSV/Excel/PDF）

---

## 6. 验收标准

| 编号 | 验收项 | 验收标准 |
|------|--------|---------|
| L-1 | 叶子科目可记账 | 选择叶子科目（如 `1001-01 现金`）创建分录 → 成功 |
| L-2 | 父科目不可记账 | 选择父科目（如 `1001 货币资金`）创建分录 → 400 错误，提示选择末级科目 |
| L-3 | 编辑分录校验 | 编辑分录将科目改为父科目 → 400 错误 |
| L-4 | 批量记账校验 | 批量记账中某条选了父科目 → 该条返回错误，不影响其他条 |
| L-5 | 历史分录自动迁移 | 给有分录的叶子科目新增子科目 → 自动创建待分类子科目，历史分录迁移至待分类 |
| L-6 | 无分录科目不迁移 | 给没有分录的叶子科目新增子科目 → 不创建待分类子科目 |
| L-7 | 迁移信息返回 | 创建子科目 API 响应中包含 `migration` 字段，告知迁移了多少条分录 |
| L-8 | AccountPicker 父节点不可选 | 前端点击父节点仅展开/折叠，不触发选中 |
| L-9 | AccountPicker 叶子节点可选 | 前端点击叶子节点正常选中并关闭 |
| L-10 | 视觉区分 | 父节点灰色文字，叶子节点正常颜色 |
| L-11 | `is_leaf` 字段 | 科目树 API 返回 `is_leaf` 字段，叶子为 `true`，父为 `false` |
| L-12 | 新账本科目结构 | 新建账本自动灌入重构后的科目树（货币资金 > 现金/存款 > 银行/支付） |
| L-13 | 动态叶子判定 | 用户给叶子科目新增子科目后，原科目自动变为不可记账 |
| L-14 | 有分录科目不可删 | 删除有分录引用的科目 → 400 错误，提示先迁移分录 |
| L-15 | 有子科目不可删 | 删除有活跃子科目的科目 → 400 错误，提示先删除子科目 |
| L-16 | 无引用科目可删 | 删除无分录引用且无子科目的科目 → 成功 |

---

## 7. 约束与风险

| 约束/风险 | 说明 | 缓解措施 |
|----------|------|---------|
| 已有分录引用父科目 | 历史数据可能存在记在父科目上的分录 | 新增子科目时自动迁移到「待分类」子科目，保证数据干净 |
| 自动迁移的侵入性 | 迁移会修改历史分录行的 `account_id` | 迁移在事务中执行，失败时回滚；API 响应明确告知迁移结果 |
| 性能 | `_check_is_leaf` 每次记账需多一次 COUNT 查询 | 轻量查询，可用索引优化（`parent_id` 列已有索引） |
| MCP 兼容 | MCP Tool 通过 REST API 记账，自动继承约束 | 错误信息返回 LLM 可理解的文本 |
| 科目体系仅影响新账本 | 旧账本保持原结构 | 可选迁移脚本或手动调整 |
